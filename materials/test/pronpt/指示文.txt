ステップ0：前提条件の共有（最初のプロンプト）
まず、ChatGPTにプロジェクトの全体像と役割分担を記憶させます。

# 指示：
これから、あなたには私の開発パートナーとして、あるゲームの解析システムを開発する手伝いをしてもらいます。
以下の【プロジェクト概要】と【ゲームの特別ルール】を完全に記憶し、今後の私たちの対話全てにおいて、この設定を厳密に維持してください。

---
### 【プロジェクト概要】

**目的:** 組み合わせゲーム理論に基づき、「石取りゲーム」という二人零和有限確定完全情報ゲームの解析システムを開発する。
**開発言語と役割分担:**
1.  **解析エンジン (Solver):** **C++**で実装します。高いパフォーマンスでゲームの完全解析を行い、結果をJSONファイルとして出力することが目的です。
2.  **可視化ツール (Visualizer):** **Python**で実装します。Solverが出力したJSONを読み込み、結果をグラフィカルに表示することが目的です。

### 【ゲームの特別ルール】
**ゲーム名:** 石取りゲーム (1x3ミニ版)
**盤面:** 1x3 のマス（`std::vector<int>`で表現）
**プレイヤー:** 黒(1), 白(-1)

1.  **勝利条件:** 相手の石を**1つでも**捕獲した時点で、そのプレイヤーの勝利となり、ゲームは即座に終了する。
2.  **パスの禁止:** 合法手がある限り、パスはできない。
3.  **自殺手の禁止:** 着手した結果、自石の呼吸点が0になる手は禁止（相手の石を捕獲できる場合を除く）。
4.  **敗北条件:** 合法的な着手が存在しない場合、そのプレイヤーの負けとなる。
5.  **コウの単純化:** このミニ版では「コウ」は考慮しない。

---
# 確認：
以上の前提条件を理解し、今後の開発パートナーとして設定を維持できる場合は、「はい、前提条件を理解しました。C++で解析エンジン、Pythonで可視化ツールの開発を開始します。」とだけ返信してください。

ステップ1：【Engine in C++】ゲームクラスの実装
前提条件を理解させたら、C++でゲームのルールを実装させます。

ありがとうございます。それでは最初のステップとして、C++で解析エンジンの核となる**ゲームクラス**を作成します。

# 要件：
1.  `MiniGo1x3` という名前のC++クラスを、ヘッダーファイル (`MiniGo1x3.h`) と実装ファイル (`MiniGo1x3.cpp`) に分けて作成してください。
2.  コンストラクタは、盤面状態 `std::vector<int>` と手番 `int` を受け取ります。
3.  `get_legal_moves()` メソッドを実装してください。
    * 自殺手禁止のルールを考慮し、現在のプレイヤーが着手可能なすべての座標（0, 1, 2）を `std::vector<int>` で返します。
4.  `make_move(int move)` メソッドを実装してください。
    * 指定された `move` に石を置き、捕獲処理を実行します。
    * 新しい盤面状態を持つ `MiniGo1x3` の新しいインスタンスと、捕獲が発生したかどうかを示す `bool` 値のペア (`std::pair<MiniGo1x3, bool>`) を返します。
5.  簡単な動作確認のため、`main.cpp` ファイルに、初期盤面から合法手をリストアップし、一つ着手してみるサンプルコードを含めてください。
6.  コンパイルと実行の方法も示してください（例: `g++ -std=c++17 *.cpp -o solver && ./solver`）。



ステップ2：【Engine in C++】解析ロジックとNode構造の実装
ゲームクラスを元に、ゲーム木を探索・解析するロジックを実装させます。

素晴らしいです。先ほど作成した `MiniGo1x3` クラスを使って、次に**ゲーム木を探索するSolver**を実装します。

# 要件：
1.  `GameNode` という構造体 (`struct`) を定義してください。仕様書にある以下のフィールドを持たせます。
    * `id` (string), `board_state` (vector<int>), `player_to_move` (int), `children` (map<string, string>), `game_value` (string), `outcome_class` (string), `is_optimal` (bool)
2.  `Solver` というクラスを作成してください (`Solver.h`, `Solver.cpp`)。
3.  `solve(initial_board, initial_player)` というメインメソッドを持たせます。
4.  このメソッドは、再帰的な探索関数（例: `_find_value`）を内部で呼び出します。
5.  探索には**メモ化**を必ず使用してください。盤面と手番から生成したキーを使い、計算済みの `GameNode` へのポインタを `std::map` や `std::unordered_map` に保存します。ノードの管理には `std::unique_ptr` を使うと良いでしょう。
6.  再帰のベースケース（終局）から戻る際に、各ノードの `game_value` と `outcome_class` を決定するロジックを実装してください。

この `GameNode` 構造体と `Solver` クラスのコードを生成してください。`main.cpp` では `Solver` を呼び出して解析を実行する形に修正してください。


ステップ3：【Engine in C++】JSON出力機能の実装
解析結果をデータとして出力できるようにします。C++では外部ライブラリを使うのが現実的です。

完璧です。これで解析の心臓部ができました。最後に、Solverに**解析結果をJSONファイルとして出力する機能**を追加します。

# 要件：
1.  C++でJSONを扱うため、広く使われているヘッダーオンリーライブラリ **`nlohmann/json`** を使用することを前提とします。`#include "json.hpp"` のようにインクルードするだけで使えます。
2.  `Solver` クラスに `save_to_json(const std::string& filepath)` というメソッドを追加してください。
3.  このメソッドは、`solve`メソッド実行後にメモ化マップに保存された全ての `GameNode` オブジェクトを、仕様書で定義したJSON形式に整形してファイルに書き出します。
4.  `main.cpp` で、解析後にこのメソッドを呼び出し、`analysis_1x3_m1.json` という名前のファイルを出力するようにしてください。
5.  `nlohmann/json` ライブラリの入手方法（GitHubからダウンロードするだけ）についても簡単な注釈を加えてください。


ステップ4：【Visualizer in Python】ゲーム木のグラフィカル表示
ここからはPythonでの作業です。C++エンジンが出力したJSONを可視化します。

C++での解析エンジン開発は完了です。これからはPythonで**可視化ツール**を開発します。
解析エンジンが `analysis_1x3_m1.json` を出力したと仮定します。

# 要件：
1.  `visualize_tree.py` という名前のPythonスクリプトを作成してください。
2.  このスクリプトは、コマンドライン引数としてJSONファイルのパスを受け取ります。
3.  Pythonの `graphviz` ライブラリと `json` ライブラリを使用します。
4.  JSONファイルを読み込み、`nodes` 内の全ノードと親子関係を元に、ゲーム木を表すDOT言語のソースを生成し、画像ファイル（例: `gametree.png`）として出力してください。
5.  以下の仕様で画像を作成してください。
    * ノードには `game_value` と `outcome_class` を表示する。
    * `outcome_class` に応じてノードを色分けする（P=緑, N=橙, L=青, R=赤）。
    * 親ノードから見て `is_optimal` が `true` の子ノードへの辺は、太線で表示する。

このPythonスクリプトのコードを生成してください。


ステップ5：【Visualizer in Python】最善手棋譜ログの生成
最後に、最善手の流れをテキストで分かりやすく表示する機能を作成させます。

最後の機能です。JSONファイルから**最善手の進行のみを抜き出し、分かりやすい棋譜ログとして出力する**Pythonスクリプトを作成します。

# 要件：
1.  `generate_log.py` という名前の新しいPythonスクリプトを作成してください。
2.  このスクリプトも、コマンドライン引数としてJSONファイルのパスを受け取ります。
3.  JSONファイルを読み込み、ルートノードから `is_optimal` フラグが `true` の子ノードを再帰的に辿ります。
4.  各ステップで、以下の形式のログをコンソールに出力してください。
    * 手番、着手座標
    * 1x3盤面のASCIIアート表示（例: `[W, X, _]`）
    * その局面の `game_value` と `outcome_class`

このPythonスクリプトのコードを生成してください。