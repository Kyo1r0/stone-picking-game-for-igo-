# 組み合わせゲーム理論・石取りゲーム解析システム 仕様書
## 1. プロジェクト概要
本プロジェクトの目的は、囲碁のルールを元にした「石取りゲーム」を組み合わせゲーム理論に基づき解析するシステムを開発することである。システムは、ゲームの数学的構造を解明し、その結果を人間が理解しやすい形で可視化する機能を持つ。

## 2. システム構成
システムは以下の2つの独立したコンポーネントで構成される。両者はJSONファイルを介して連携する。

- ① 解析エンジン (Solver): ゲームのルールを実装し、与えられた条件での完全解析を行い、結果をJSON形式で出力する。

- ② 可視化ツール (Visualizer): 解析エンジンが出力したJSONファイルを読み込み、多様な形式でグラフィカルに表示する。

## 3. コンポーネント別仕様
# ① 解析エンジン (StoneCaptureSolver)
3.1. 目的
指定された盤面サイズ n と勝利条件 m における石取りゲームの全ての局面を解析し、各局面の「ゲームの値」と「帰結類」を計算し、ゲーム木構造としてJSONファイルに出力する。

### 3.2. 入力
盤面サイズ n: 整数 (e.g., 3)

勝利条件 m: 整数 (e.g., 1)

### 3.3. 出力
解析結果をまとめたJSONファイル。ファイル名は analysis_n{n}_m{m}.json の形式とする。

### 3.4. 主要機能
- ゲームルール実装

盤面管理: n x n の2次元配列で盤面を表現する (0: 空点, 1: 黒, -1: 白)。

合法手判定: 指定された座標が空点であるか、自殺手でないか、超コウ（過去の盤面と同一にならないか）を判定する。

石の捕獲処理: 着手後に相手の石の呼吸点が0になったグループを盤上から取り除くロジックを実装する。

- ゲーム木探索アルゴリズム

再帰関数: solve(board, player) のような再帰関数でゲーム木を深さ優先で探索する。

メモ化: (盤面タプル, 手番プレイヤー) をキーとして、一度計算した局面の結果（GameNodeオブジェクト）を辞書（ハッシュマップ）に保存し、再計算を防ぐ。

- ゲームの値の計算

探索の過程（葉から根へ戻る際）で、各局面（ノード）の値を決定する。

game_valueの計算: 子ノードのgame_valueを収集し、"{左選択肢の値 | 右選択肢の値}" という文字列を生成する。

outcome_classの計算: 子ノードの帰結類を元に、または計算したgame_valueと0を比較して、その局面の帰結類（N, P, L, R）を決定する。

### 3.5. データ構造
GameNode 構造体 / クラス
```
id: string (局面を一意に識別するハッシュ値など)

board_state: list[list[int]] (盤面状態)

player_to_move: int (1: 黒, -1: 白)

children: dict (着手座標 "(x,y)" をキー、子ノードの id を値とする辞書)

game_value: string (計算されたゲームの値。例: "{0|*}")

outcome_class: string (計算された帰結類。例: "L")

is_optimal: bool (親ノodeから見て、このノードへの遷移が最善手かどうかのフラグ)
```

- JSON出力形式
```
JSON

{
  "metadata": {
    "n": 3,
    "m": 1,
    "root_node_id": "id_of_root"
  },
  "nodes": {
    "id_of_root": {
      "board_state": [[0,0,0],[0,0,0],[0,0,0]],
      "player_to_move": 1,
      "children": { "(0,0)": "id_of_child1", "(1,1)": "id_of_child2" },
      "game_value": "...",
      "outcome_class": "N"
    },
    "id_of_child1": { ... }
  }
}
```
# ② 可視化ツール (StoneCaptureVisualizer)
### 3.6. 目的
StoneCaptureSolver が生成したJSONファイルを読み込み、人間が直感的に理解できる形式でアウトプットする。このツールはゲームのルールを一切関知しない。

### 3.7. 入力
解析済みJSONファイルのパス。

### 3.8. 出力
画像ファイル (PNG, SVG)、テキストファイル (TXT)、またはWebページ (HTML)。

### 3.9. 実装する機能
ゲーム木全体のグラフィカル表示

説明: JSONデータを読み込み、Graphvizツールが解釈できるDOT言語形式に変換し、ゲーム木全体の画像を出力する。

仕様:

ノードにはgame_valueとoutcome_classを表示する。

outcome_classに応じてノードを色分けする (例: P=緑, N=橙, L=青, R=赤)。

is_optimalがtrueの辺（エッジ）を太線で表示する。

最善手棋譜ログの生成

説明: JSONデータからis_optimalフラグを辿ることで最善手の進行を抽出し、注釈付きの棋譜としてテキスト出力する。

仕様:

各手番で、盤面をASCIIアートで表示する。

着手座標、計算されたgame_value、outcome_classを併記する。

（発展）N/Pポジション・ヒートマップの生成

説明: 複数の解析結果（異なるn, mでの初期状態のoutcome_class）を元に、N/Pの分布をヒートマップとして画像出力する。

注意: この機能は、複数のJSONファイルからサマリーを読み込むか、Solverを繰り返し実行する別のスクリプトとして実装する必要がある。

## 4. 開発ステップ案
Step 1 [Engine]: ルール実装とメモ化なしの再帰探索を実装。2x2盤面で動作確認。

Step 2 [Engine]: メモ化を実装し、3x3盤面で動作することを確認。

Step 3 [Engine]: GameNode構造体とJSON出力機能を実装。

Step 4 [Visualizer]: JSONを読み込み、Graphvizでゲーム木を描画する基本機能を実装。

Step 5 [Visualizer]: 最善手棋譜ログ生成機能、ヒートマップ生成機能を追加開発。